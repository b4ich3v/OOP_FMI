# Задача 1:
Да се реализира шаблон на клас Matrix, който представлява двумерен масив от елементи. Да се реализират следните методи:

* Конструктор - заделя матрица с размер 2x2 (всички елементи са със стойност по подразбиране)

* Конструктор с параметри - размер на матрицата (всички елементи са със стойност по подразбиране)

* setAt(unsigned int x, unsigned int y, T element) - променя елемента на позиция (x,y) (x и y започват от 1)
  
* getAt(unsigned int x, unsigned int y) - връща елемент на позиция (x,y) (x и y започват от 1)

* transpose() - транспонира матрицата

# Задача 2:
Следвайки добрите ООП практики реализирайте клас GrString, предвиден за работа със символни низове , който да поддържа следните оператори :

* оператор += , който към даден стринг конкатенира друг

* оператор + , конкатенира два стринга

* оператор за четене от поток >>

* оператор == , сравнява два стринга по тежест , връща true <=> двата стринга са с еднаква тежест

* оператор /= , който като резултат дават разликата на даден стринг с друг -оператор / , връща разликата на два стринга

Упътване:
Разлика на два стринга дефинираме така: Всички символи , които се съдържат в първия стринг , но не са част от втория.
Пример : ABCDEF / BCDGHJ -> AEF
Тежест на стринг: сумата от ASCII кодовете на символите на стринга.
Демонстрирайте използването на операторите в кратка main функция.

# Задача 3:

Да се реализира шаблон на абстрактен базов клас Set, дефиниращ метода bool member (const T&). Шаблонът описва множество с елементи от тип T, а методът member дава истина за членовете на множеството.

Да се дефинират следните наследници на Set:

* Range: при конструиране на обекти се задават параметри a и b от тип T. Смятаме, че всяка стойност x, таква че a <= x <= b, принадлежи на множеството
* EvenNumbers: смятаме, че елементите на това множество са всички числа x от тип int, за които x % 2 == 0
* Container: позволява добавяне на произволен брой елементи от тип T, като всяка различна стойност от тип T може да се съдържа само по веднъж в контейнера. За елементи на множеството, съответно на контейнера, се считат добавените в него елементи. За класът да се реализират:
  *  Метод add за добавяне на елемент в контейнера
  *  Оператор за обединение (+) на два контейнера. Резултатният контейнер съдържа тези елементи, които са срещат в поне един от двата изходни контейнера
* Да се реализира клас ManySets. Класът служи като колекция от множества, наследници на Set и да позволява добавяне на множество от произволен тип. Да се реализират оператор << и >> за ManySets, позволяващи сериализация и десериализация на ManySets от поток. Да се реализират всички необходими допълнителни методи (serialize(ostream& os), deserialize(istream& is)) в йерархията на Set. Да се демонстрира сериалзиацията и десериализацията с примерна програма. Помислете за удачен формат формат за сериализиране.

* Бонус: ManySets да се разшири така, че да стане член на йерархията Set и да може един ManySet да съдържа други ManySet. Методите за сериализация и десериализация да се разширят така, че да поддържат и ManySet

# Задача 4:

Да се реализира софтуер за магазин. В магазина ще се продават следните типове артикули - плод и зеленчук Да се напишат следните класове и техните член-данни/методи: Клас StoreItem (абстрактен): Член-данни:

* Тип на продукта (enum)
* Калории на продукта (цяло положително число) (0 по подразбиране)
* Цена (дробно число) (0 по подразбиране) Методи:
* Get() за всяка член-данна
* Set() за всяка член-данна
* Конструктор с параметри

Клас Fruit: (наследява StoreItem) Член-данни:

* Тип на продукта: плод
* Име на плода (string)
* Цвят на плода (string) Методи:
* getName() - връща името на плода
* Set() за всяка член-данна
* Конструктор с параметри
* Оператор > - сравнява два продукта по брой калории
* print() - да изведе информацията на продукта на конзолата

Клас Vegetable: (наследява StoreItem) Член-данни:

* Тип на продукта: зеленчук
* Име на зеленчука (string)
* Сорт (string) Методи:
* getName() - връща името на зеленчука
* Set() за всяка член-данна
* Конструктор с параметри
* Оператор == - сравнява два продукта по сорт
* print() - да изведе информацията на продукта на конзолата

Клас Shop: Служи като контейнер за артикулите в магазина. Член-данни:

* Хетерогенен контейнер за атрикулите в магазина Методи:
* Добавяне на продукт (приема продукта като аргумент)
* Премахване на продукт (приема индекс)
* Промяна на цена на продукт (приема индекс и цена)
* Промяна на име на продукт (приема индекс и ново име)
* Извежда информация за всички продукти на конзола
* Намира плода с най-много калории

# Задача 5:

Да се реализира нов език за обмен на данни - FJSON (fake json), който представлява колекция от различни двойки (pairs). Всяка двойка се състои от наименование (key) и стойност (value). Всяко наименование трябва да бъде низ с произволна дължина. Различават се четири типа двойки в зависимост от типа на стойността:

* Със стойност низ (StringPair) - низът е с произволна дължина
  * ключ: stringId
  * стойност: Hello World

* Със стойност дата (DatePair)
  * ключ: First uni day
  * стойност: дата, състояща се от ден месец и година

* Със стойност време (TimePair)
  * ключ: Work day start
  * стойност: време, състоящо се от час и минути(часът е от 0 до 23 часа)

* Със стойност дата и време (DateTimePair)
  * ключ: OOP Exam
  * стойност: дата и време, състои се от ден, месец, година, час и минути

Представянето на стойността трябва да е оптимално за съответния тип двойка. Коректността на входа за датата и времето НЕ е гарантирана. При валидацията за датата може да приемете, че дните във всички месеци са 31. При подадени невалидни стойности, същите се заменят с валидна стойност по подразбиране - 31 за ден, 12 за месец, 00:00 за време и се извежда подходящо съобщение.

Да се реализира член-функция save(ostream& os), която да връща FJSON под формата на низ. Всяка двойка трябва да бъде форматирана в изходния низ по следния начин:

* Със стойност низ (StringPair) - {stringId : “Hello world”}
* Със стойност дата (DatePair) - {First uni day : 15.10.2021}
* Със стойност време (TimePair) - {Work day start, 10:15}
* Със стойност дата и време (DateTimePair) - {OOP Exam: 23.06.2021, 09:04} Резултатния низ трябва да започва с ‘[‘, да завършва с ‘]’ и да са изредени неговите стойности, разделени със запетаи.

Пример:

[{stringId : “Hello world”}, {First uni day : 15.10.2021}, {Work day start, 10:15}, {OOP Exam:
23.06.2021, 09:04} ]
Реализирайте главна функция, която създава FJSON обект и множество стойности в него и тества реализираните функционалности.
