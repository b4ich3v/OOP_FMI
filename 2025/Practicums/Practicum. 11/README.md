# Задача 1:
Smart Home System
Трябва да разработите програма за управление на различни типове устройства в система за "умни домове". Системата поддържа устройства като Smart Light, Smart Thermostat и Smart Speaker. Всеки тип устройство има специфични атрибути и поведение.

Изисквания: Абстрактен базов клас Device със следните pure virtual функции:

* turnOn()
* turnOff()
* printDetails()

Освен тях, базовият клас има име и производител (MyString) и цена (реална стойност).

Класът Device има следните 3 наследници:

* SmartLight : има атрибут brightnessLevel, отговарящ за светимостта.
* SmartThermostat: има атрибути за настояща температура и желана температура.
* SmartSpeaker: има допълнително поле за сила на звука.

Презапишете функциите turnOn, turnOff и printDetails за всеки от класовете, така че да изписват на конзолата конкретно съобщение за вида смарт устройство.

Създайте и клас SmartHome, който да представлява хетерогенен контейнер от смарт устройтва. Класът да поддържа и следните функционалности:

* Добавяне на смарт устройство
* Премахване на смарт устройство
* Принтиране на всички налични устройства
* Включване/изключване на устройство на подаден индекс
* Намиране на средна цена на устройства от даден производител

# Задача 2:
Computer Components Configuration
Един компютър се състои от един или повече компоненти. Всички компоненти са immutable обекти. След като веднъж бъдат създадени, свойствата им не могат да се променят. Всеки компонент да има:

* Етикет, който е символен низ с произволна дължина
* Функция double price() const, която връща цената на компонента. Тя ще се имплементира от всеки конкретен компонент и ще пресмята цената по някакво правило.
* Фунцкия void output(std::ostream) const, която ще принтира данните за компонента. Тя ще се имплементира от всеки конкретен компонент.

Програмата ви трябва да поддържа два конкретни компонента – процесор (CPU) и памет (Memory).

Процесорът има брой ядра (cores) и честота в MHz (clock speed). И двете са числа от тип unsigned short. Броят на ядрата може да е между 1 и 8. Цената на процесора се смята като броя на ядрата, умножен по 29.99 лева. Паметта има капацитет (capacity) в гигабайти (GBs) (unsigned short). Трябва да е число между 1 и 10000 Цената на паметта е 89.99 лева на гигабайт.

Ако се опита да се създаде компонент с некоректно подадени параметри, да се хвърли изключение.

Реализирайте подходяща йерархия, за да представите горе-описаната ситуация. Проектирайте йерархията по всички добри практики, така че да позволява лесно добавяне и на други видове компоненти в бъдеще. Например помислете какъв трябва да е деструкторът, кои операции да са pure virtual и кои да изнесете в базовия клас и т.н.

Напишете клас Configuration, представящ конфигурация. Класът трябва да може да съхранява в себе си различни видове компоненти. Класът да има следните член-функции:

* void insert(Component* component), която добавя нов компонент към конфигурацията. Функцията директно да съхранява указателя, без да прави копие на подадения компонент.
* double price() const – връща цената на конфигурацията. Пресмята се като сума от цените на всички компоненти.
* size_t size() const – връща броя на компонентите в конфигурацията.

За класа предефинирайте следните оператори:

* operator [] - позволява константен достъп до обект в конфигурацията
* operator <<, който извежда информация за конфигурацията в std::ostream. При извеждането най-напред да се изведат един по един всички компоненти, използвайки техните функции output. Накрая, да се изведе и още един ред с общата цена на конфигурацията.
Напишете factory функция Component* Create_Component(). Тя трябва да попита потребителя какъв тип компонент иска да създаде – процесор или памет. След това тя въвежда съответните му характеристики, създава динамично обект от съответния тип и го връща. Ако потребителят въведе невалиден тип или създаването на обект е неуспешно, да се върне nullptr.

# Задача 3:
Множества
Да се реализира абстрактен базов клас IntSet, който описва следните операции върху изброимо крайно множество от цели числа:

* bool member(int x) - проверява дали цялото число x е елемент на множество.
* int get(int i) - връща i-тия елемент на множество. Индексацията на елементите е без значение.
* bool isSubsetOf([попълнете правилния тип] s) - проверява дали дадено множество е същинско подмножество на s.
* bool intersects([попълнете правилния тип] s) - проверява дали две множества имат непразно сечение.

Да се реализират наследници IntRange и ArraySet. Клас IntRange представя затворен интервал от цели числа. Краищата на интервала да се задават при конструиране на обекта. ArraySet е клас, поддържащ множество от максимум n цели числа, където n се задава по време на конструиране на обекта. ArraySet да поддържа следните операции:

* bool insert(int x) - добавя числото x към множеството. Ако капацитетът е изчерпан или числото се съдържа в множеството вече, връща лъжа. Връща истина в противен слуай.
* bool remove(int x) - премахва числото x от множеството. Ако елементът не съществува, резултатът е лъжа. Резултатът е истина в противен случай.
  
# Задача 4:
Да се разработи програма, която позволява четене, обработка и запис на масиви от цели числа между файлове с различни формати (текстови, бинарни и CSV).
Програмата трябва да бъде реализирана с помощта на добре структурирана йерархия, полиморфизъм и прилагане на Factory Method .

Базови абстрактни класове:
FileReader:

* Съдържа име на файл (MyString fileName).
* Декларира чисто виртуална функция:
* virtual void read(int*& arr, size_t& size) const = 0;

FileWriter:

* Съдържа име на файл (MyString fileName).
* Декларира чисто виртуална функция:
* virtual void write(const int* arr, size_t size) const = 0;

Производни класове за различни файлови формати:
Формат	Reader клас	Writer клас	Формат на съдържанието
Текстов файл (с интервали)	ArrayFileReader	ArrayFileWriter	Числата са разделени с интервали.
Бинарен файл	BinaryFileReader	BinaryFileWriter	Числата са записани/четени в двоичен (binary) формат.
CSV файл	CSVFileReader	CSVFileWriter	Числата са разделени със запетаи ,.

Обекти се създават чрез (Factory Pattern):
* FileReader* fileReaderFactory(const MyString& fileName)
* FileWriter* fileWriterFactory(const MyString& fileName)
Тези функции трябва да създават подходящ FileReader или FileWriter обект в зависимост от разширението на файла (.csv, .dat, .arr).

Операция по трансфер на данни:
Имплементирайте функция:

* void transfer(const MyString& fromName, const MyString& toName);

# Задача 5:
Да се реализира йерархия от компютри.
Да се реализира:
Абстрактен клас Computer. В себе си той съдържа:

* Мощност на процесора (число тип double)
* Модел на видео картата (масив от символи)
* Мощност на захранването (цяло число)
* Количество RAM памет (цяло число)
* Методи за промяна на компонентите на компютъра
* Функция, която изписва на стандартния изход какъв тип е компютъра (PC, лаптоп или геймърска конзола)
* Функция, която връща с какви периферни устройства може да се свързва компютъра.

Нека перферните устройства са масиви от символи.

Класове PC, Laptop и GamingConsole

* PC може да се свързва с мишка, клавиатура, микрофон и слушалки.
* Laptop - с mouse pad, клавиатура и монитор.
* GamingConsole - с джойстик и монитор.

# Задача 6:
Създайте проста йерархия, описваща потребители, логващи се като играчи. Създайте клас Player. Всеки играч има

* ID в нашата система (от тип int)
* точки (изберете подходящ тип)
* звезди (от 1 до 5 - enum class)

Когато играча изпълнява мисии, той печели точки. Когато печели точки, той може да ги обменя за звезди. Реализирайте подходящи член функции. Също така, реализирайте функция bool levelUp(); Тя проверява дали имаме достатъчно точки да обменим за допълнителна звезда, и, ако имаме, ги обменя.

* В началото имаме една звезда
* За две звезди ни трябват 256 точки
* За три звезди ни трябват 512 точки и вече постигнати 2 звезди
* За четири звезди ни трябват 1024 точки и вече постигнати 3 звезди
* За пет звезди ни трябват 2048 точки и вече постигнати 4 звезди.
* Ако нямаме достатъчно точки да обменим за звезди, функцията връща false, в противен случай връща true.

Реализирайте клас Guest, който представлява гост в нашата игра. Гостът има допълнителна член-данна, която показва колко време може да играе, преди да бъде изключен от играта. Също така гостът не може да вдига звезди - винаги стои на една звезда!

Направете клас, който описва Логнат потребител. Той има парола от най-много 8 символа и ще се логва в системата чрез своето ID и своята парола. Създайте подходящи член функции. Функцията levelUp работи както за Player.

Реализирайте клас PremiumPlayer който описва играч, платил, за да има допълнителни екстри в нашата игра. Той вече ще може да праща съобщения в чат, което означава, че трябва да има име. Името ще е низ с произволна дължина. Също така на него ще му е по-лесно да вдига звезди - всяка нова звезда се получава с 256 точки.

# Задача 7:
Награда Ще реализираме йерархия, описваща награди, които нашия потребител може да си купи. Реализирайте абстрактен клас, който описва Награда. Всяка награда има цена и точки, които трябва да дадем, за да я получим. Също така всяка награда има функция visualize(), която показва на стандартния изход каква точно е нашата награда.

Наградите, с които разполагаме, са

* Penguin - 50 точки
* Pacman - 150 точки
* computerBoy - 500 точки
* squidward - 1000 точки
* sylvester - 1500 точки
