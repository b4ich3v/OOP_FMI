# Задачта 1.
Билети за театрална постановка
Реализирайте клас Ticket, който описва билет за театрална постановка. Всеки билет има:

* име на постановката от тип MyString
* цена от тип double
  
Направете подходящи конструктори.

Реализирайте клас StudentTicket, който е наследник на Ticket:

* билетът е 2 пъти по-евтин
* в конструктора си приема име и оригинална цена за постановката

Реализирайте клас GroupTicket, който е наследник на Ticket:

* билетът е с 20% по-евтин от нормалния
  
Направете подходящи функции за принтиране на информацията за билетите.

# Задачта 2.
UNIX Timestamp
UNIX времево клеймо (timestamp), още наричано "epoch time", е цяло число, указващо брой секунди изминали след 1 януари 1970 г. UTC. Такова клеймо позволява всеки момент във времето след 01.01.1970 г. да се съхранява като едно-единствено цяло число. Ако едно клеймо A е по-малко от друго клеймо B, можем да заключим, че A е момент от времето, който е преди B.

Да се реализира клас Timestamp, представящ UNIX времево клеймо. Класът да целочислена съдържа променлива, пазеща клеймото. Да се реализират:

* Подходящи конструктори
* Гетъри и сетъри
* Оператори за вход и изход от поток
* Оператор +=, който получава цяло число (брой секунди) и ги добавя към текущия timestamp

Да се реализира наследник TimestampWithDescription, който в себе си да пази и описание. Описанието е символен низ с произволна дължина. Да се реализират:

* Подходящи конструктори
* Гетъри и сетъри
* Оператори за вход и изход от поток

# Задачта 3.
База данни за студенти
Клас Student
Създайте клас Student, който съдържа следната информация:

* име (от тип MyString)
* факултетен номер (от тип unsigned)
* курс, в който учи (от тип unsigned)

Клас StudentDB
Да се реализира клас StudentDB, който представлява база от данни за съхранение на информацията за студенти. Класът да поддържа следните функционалности:

* add - добавяне студент в базата
* remove - премахване на студент от базата по подаден факултетен номер
* find - търсене на студент в базата по подаден факултетен номер
* display - визуализира информация за базата данни

Клас SortedStudentDB
Да се реализира клас SortedStudentDB, който наследява StudentDB и поддържа следната допълнителна функционалност:

* sortBy - запазва студентите сортирани по подаден критерий

Клас FilteredStudentDB
Да се реализира клас FilteredStudentDB, който наследява StudentDB и поддържа следните допълнителни функционалности:

* filter - по подаден критерий запазва в базата данни само студентите, които го изпълняват
* limit - по подаден брой N запазва само първите N студенти в базата

# Задачта 4.
(A) Създайте клас CarPart, описващ част за кола.

Всяка част за кола има:

* идентификатор - уникално число > 0;
* име на производител - низ с произволна дължина;
* описание - низ с произволна дължина.

(B) Майсторът в момента главно се интересува от двигатели, гуми и акумулатори.

Гумите имат:

* широчина в мм – между 155 и 365;
* профил – между 30 и 80;
* диаметър в инчове – между 13 и 21.

Двигателите се характеризират с конски сили.

Акумулаторите имат:

* капацитет – в ампер-часове;
* battery id – идентификатор, независим от този за всяка част (низ с произволна дължина)
* Реализирайте подходящи класове за различните части.
* Създайте и подходящи оператори <<, които да извеждат информация за част в следния формат:

Направете подходящ клас FuelTank за целта.

* Един резервоар има капацитет и пълнота към момента. И двете стойности се измерват в литри и са реални числа.
* Създайкте конструктор, приемащ капацитет на резервоара. Всеки нов резервоар първоначално е пълен.

Създайте методи:

за използване на дадено количество гориво:

* void FuelTank::use(double toUse);
за зареждане на дадено количество гориво:

* void FuelTank::fill(double toFill);
При зареждане на прекалено много гориво, резервоарът остава пълен.

При опит за използване на количество гориво, повече от наличното, да се хвърля custom изключение insufficient_fuel_error.

Изключението трябва да е пряк наследник на std::logic_error и да може да се създава такова с единствен параметър – съобщение, описващо грешката.

Използвайте някой конструктор на std::logic_error, за да изградите този на insufficient_fuel_error.

Реализирайте клас Car, използвайки частите, които създадохте.

Една кола има поне:

* резервоар;
* двигател;
* 4 гуми;
* акумулатор;
* изминати километри;
* тегло (в кг).

Създайте конструктор за кола, приемащ всички нужни член данни, както и капацитет на резервоара.
Създайте get-ър за резервоара:

* const FuelTank& getFuelTank();
Създайте член-функция drive(double km). Резултатът от изпълнението на функцията е:

* добавя се дистанцията към изминатите километри;
* намалява се количеството гориво в резервоара с произведението на km и изразходваното гориво на 1 км; горивото, използвано за 1 км се счита че е 1л/км
* Ако колата няма достатъчно гориво, не се променя състоянието ѝ по никакъв начин.
* Създайте външна за класа функция за драг състезание между две коли:
* Car* dragRace(Car* car1, Car* car2);
* To се случва на разстояние 0.4 km (1/4 mile). Функцията трябва да връща Car*, сочейки към евентуалния победител от него.

Ако една от колите няма достатъчно гориво, за да измине разстоянието, другата печели. Ако и двете коли нямат достатъчно гориво, да се върне nullptr. Ако и двете коли имат достатъчно гориво, победителят се определя от съотношението: тегло / конски сили на двигателя Колата с по-високо съотношение печели.
