# Задача 1. 
Да се напише програма, която чете матрица от текстов файл от вида : 3,3,3|1,1,3|3,3,1, чете друга матрица в същия формат от втория файл и записва произведението им в нов файл (броят на колоните винаги е 3).

# Задача 2.  
Да се напише структура, която съхранява информация за доставка на пица. Да се създаде масив от доставки - списък с поръчки. Една поръчка съдържа име на клиента (до 50 символа), телефонен номер (до 20 символа), адрес на потребителя(до 100 символа), общата стойност на доставката и броят пици. Структурата на пицата трябва да съдъжа типа на пицата { Маргарита, калцоне, бурата и каквато още пожелаете}, размер на пицата {S,M,L}, цена на пицата. Да се имплементират функции, които позволяват съхраняването и изчитането на информацията за поръчките от двоичен файл. Да се сортират поръчките в масива по адрес на доставка и да се запише в нов двоичен файл.

# Задача 3. 
Да се създаде структура Jedi със следните характеристики:

* Име (максимална дължина 50 символа)
* Възраст
* Сила
* LightSaber
Всеки лазер да се опише със следните полета:

* Цвят - RED, YELLOW, GREEN, BLUE, PURPLE
* Тип - SINGLEBLADED, DOUBLE_BLADED, CROSSGUARD

Да се напише структура JediCollection, която да може да пази в себе си най-много 100 джедая и техния брой. Да се реализира следния набор от функции:

* Jedi createJedi(const char* name, unsigned age, unsigned power, const LightSaber& saber) – създава нов джедай с подадените параметри. Да се реализира overload, приемащ създаден цвят и тип на лазер
* void addJedi(JediCollection& collection, const Jedi& jedi) – добавя джедай в подадената колекция
* void removeJedi(JediCollection& collection, const char* name) – премахва джедая с подаденото име от колекцията
* void printJediCollection(const JediCollection& collection) – принтира подадената колекция
* void saveCollectionToBinary(const char* fileName, const JediCollection& collection) – запазва колекцията в подадения двоичен файл
* JediCollection readCollectionFromBinary(const char* fileName) – прочита и създава колекция, записана в двоичен файл
* void saveCollectionToTxt(const char* fileName, const JediCollection& collection) – запазва колекцията в подадения текстов файл
* JediCollection readCollectionFromTxt(const char* fileName) – прочита и създава колекция, записана в текстов файл
* void sortByAge(JediCollection& collection) – сортира колекция във възходящ ред по възраст
* void sortByPower(JediCollection& collection) – сортира колекция във възходящ ред по сила
* Color mostPopularSaberColor(const JediCollection& collection) – връща най-използвания цвят на лазер от джедаите в колекцията
* Type mostPopularSaberType(const JediCollection& collection) – връща най-използвания тип на лазер от джедаите в колекцията

# Задача 4. 
Да се напише структура Car, която да съдържа, марка (enum class, създайте няколко енумератора по избор) име на собственик (символен низ с максимална дължина 24 символа), средна скорост (реална стойност), стойности на наложени глоби (реални стойности, най-много 20) и техния брой

* Да се напише функция, която пресмята сумата от всички глоби на дадена кола.
* Да се напише функция, която добавя глоба към дадена кола. Функцията да не прави нищо, ако максималният брой глоби е достигнат.
* Да се нашише функция, която извежда на стандартния изход информацията за дадена кола.
* Да се напишат функции за четене и записване на студент в подаден двоичен файл.
* Бонус: Да се напише функция, която чете масив от коли с произволна дължина от двоичен файл. Функцията сортира колите по средна скорост във възходящ ред и ги записва обратно в двоичния файл.

# Задача 5. 
Да се направи функция, която "разшифрова" скрито съобщение. Съобщението представлява двоичен файл с неизвестна дължина. Това, което съхранява е поредица от цели неотрицателни числа.

"Ключът" за съобщението се съхранява в друг двоичен файл и представлява число в интервала [0, 255]. Преценете как е най-подходящо да прочетете и съхраните ключа. Шифърът за получаване на правилното съобщение е към всяко число от прочетения файл, съдържащ съобщението да се добави стойността на прочетения ключ

Пояснение: Aко файлът със скритото съобщение след прочитане изглежда така: 23 48 3 12 4006, файлът, съдържащ ключа има стойност 2, то разшифрованото съобщение трябва да е: 25 50 5 14 4008. Изведете разшифрованото съобщение на конзолата.

# Задача 6.
Имате файл, съдържащ записи, които са организирани в свързан списък. Някои от записите във файла вече не се използват (били са премахнати от списъка и вече не са част от него). За съжаление, по GDPR вие нямате право да пазите дълго време потребителски данни, които не се използват – затова трябва да напишете програма, която цензурира неизползваните записи.

Програмата се извиква с един аргумент (име на файл): maintasks.db

Файлът се състои от последователни 512-байтови записи, всеки от които описва възел и има следния вид:

* next: 8 байта, представящи 64-битово число без знак – индекс на следващия възел (в брой записи спрямо началото на файла), или 0 , ако след този възел няма следващ
* user_data: 504 байта потребителски данни
Първият възел от списъка е винаги първи запис във файла (с индекс 0). Всеки следващ възел може да е на произволно място във файла.

Забележки:

* Забележете, че последният възел от списъка (този, който има next == 0) най-вероятно няма да е последният запис във файла
* Може да приемете, че възлите, които са в списъка, няма да образуват цикъл

# Задача 7.
Напишете структура Pokemon, който се състои от:

* име (символен низ с най-много 50 символа)
* тип (изброим тип със следните възможности: NORMAL, FIRE, WATER, GRASS, ELECTRIC, GHOST, FLYING)
* сила (цяло положително число от 10 до 1000)
Напишете следните функции:

* функция създаваща покемон от стандартния вход
* функция създаваща покемон от двоичен поток
* функция записваща покемон в двоичен поток
* Създайте структура PokemonHandler, който да се грижи за наредена по сила колекция от покемони.

Тази структура НЕ пази никакви покемони в себе си! Тя работи само с предоставения двоичен файл.

Disclaimer: Може да приемате във функциите директно fstream& И да работите с него, Идеята е да не пазите в програмата масив от покемони а да работите изцяло със файла като масив

Напишете следните функции:

* PokemonHandler newPokemonHandler(const char* filename)
тази функция създава PokemonHandler от двоичен файл
int size(const PokemonHandler &ph)
//OR
int size(std::fstream& file)
връща размера на колекцията от покемони
* Pokemon at(const PokemonHandler &ph, int i)
//OR
* Pokemon at(std::fstream& file, int i)
връщаща покемонът намиращ се на i-ти индекс (погрижете се дали тази индекс е валиден)
* void swap(const PokemonHandler &ph, int i, int j)
//OR
* void swap(std::fstream& file, int i, int j)
разменя покемоните на индекси i и j (валидирайте коректността на индексите). Идеята е да я ползвате като помощна функция
void insert(const PokemonHandler &ph, const Pokemon &pokemon)
//OR
* void insert(std::fstream& file, const Pokemon &pokemon)
добавя покемон в наредената ни колекция
* void textify(const PokemonHandler &ph, const char* filename)
//OR
* void textify(std::fstream& file, const char* filename)
записва цялата колекция в текстов файл с име filename
* void untextify(const PokemonHandler &ph, const char* filename)
//OR
* void untextify(std::fstream& file, const char* filename)
зарежда колекция от текстов файл filename. Очаква се да се изтрие всичко, което сме имали до сега в PokemonHandler
