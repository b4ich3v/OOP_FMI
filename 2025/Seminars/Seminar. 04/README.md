# Задача 1: 
Реализирайте клас Time, който ще се използва за работа с часове (13:05:45). Вашият клас трябва да има следния интерфейс:

* Подразбиращ се контруктор, който създава часа на 00:00:00.
* Конструктор, който приема три параметъра - час, минути и секунди.
* Член-функция, която връща оставащото време до полунощ.
* Член-функция, която увеличава часа с 1 секунда.
* Член-функция, която връща дали е време за вечеря. В рамките на задачата време за вечеря е между 20:30 и 22:00.
* Член-функция, която връща дали е време за парти. В рамките на задачата време за парти е между 23:00 и 06:00.
* Член-функция, която приема друг обект от тип Time и връща обект от тип Time, което е разликата между двете времена.
* Член-функция, която която приема друг обект от тип Time и сравнява двата обекта (по-къснен/по-ранен)
* Член-функция за принтиране на часа.
* Да се направи масив от 10 времена и да се сортира с някоя от изучаваните сортировки.

# Задача 2: 
Даден е двоичен файл, който е разделен на блокове – всеки с размер от 32 байта. Нашата задача е да намерим всички блокове, които участват във веригата и да построим съобщението, което ще се образува при конкатенация на всички малки съобщения от блоковете. Един блок изглежда по следния начин: { [next – 2B] [textLength – 2B] [text – up to 28B] }.

Next (2 BYTES) – кой е номерът на следващия блок
TextLength (2 BYTES) – броят на символите, които участват в текста
Text (MAX 28 BYTES) – символите, които образуват текста в блока Всеки блок си има номер, започвайти от 0. Не знаем колко е броят на всички блокове. Числото, което стои в next указва кой е номерът на следващия блок от веригата. ВЪВ ВЕРИГАТА НЯМА да има цикли. Може да има блокови, които не участват във веригата, както и че може последователността да не е строго растяща. Винаги първият блок е този с номер 0, а последният е този, на който next-a е -1. Навсякъде да се работи с точен размер на паметта.

Пример:
0 [4][3][C++…]
1 [0][6][si-oop]
2 [5][3][The….]
3 [3][5][Test….]
4 [2][2][Is….]
5 [-1][8][Greatest…]
6 [2][5][dummy…]
