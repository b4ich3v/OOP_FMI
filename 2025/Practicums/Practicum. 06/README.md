# Задача 1:
В една софтуерна компания се провежда турнир по белот с благотворителна цел.

Трябва да създадете клас BelotTournament, който да провежда турнира. За да бъде проведен един турнир, трябва да има отбори от софтуерни инженери. Всеки отбор се състои от 2 софтуерни инженери. Всеки софтуерен инженер има име (низ с произволна дължина), позиция (низ с произволна дължина) и заплата (цяло число).

Броят на отборите трябва да е четен и по-голям от 2. При опит да започне турнира с нечетен брой отбори, последният добавен отбор бива премахнат преди началото на турнира.

Когато имато достатъчно отбори, чиито участници са валидни, тогава турнирът може да започне. Отборите биват разпределени на случаен принцип. След това се провежда дуел между отборите. Един дуел може да има максимално 3 рунда, като първият отбор достигнал 2 победи, печели дуела. Един рунд се провежда като за всеки отбор се четат точки от конзолата, които се добавя към общите точки на отбора. Рунда печели отборът, който първи достигне число 151. Това се повтаря за всички печеливши отбори, докато не остане един единствен отбор, който е победител. Тъй като турнирът е с благотворителна цел, всеки от загубилите участници дарява 2% от заплатата си, а 1% дават на всеки от печелившия отбор. Да се пресметне колко пари е събрала фирмата от турнира за дарение.

# Задача 2:
Създайте клас NumberSeries, който моделира работата с числова редица. В конструктора на класа ще приемате цяло число - начална стойност на редицата (a_0) и указател към функция на преход, приемаща цяло число и връщаща цяло число (a_i = f(a_i-1)).

Трябва да имате следните функционалности:

* Генериране на i-то число от редицата.
* Проверка дали подадено число е част от редицата.
* Setter-и за нова начална стойност и нова функция на преход.
* Генерирането на стойности трябва да бъде оптимизирано откъм скорост:

За коректна работа с фунцкионалността за генериране на i-то по ред число, трябва да поддържате динамичен масив в класа, в който да пазите досега генерираните стойности.
Ако числото вече е било генерирано, трябва да го върнете като резултат без да го генерирате повторно.
Ако числото го няма в масива, генерирайте и добавете към масива всички числа, които липсват до a_i в редицата и върнете генерираната стойност.
Ако в масива няма достатъчно място, за да се съхранят новите стойности, преоразмерете го по подходящ начин.
При set-ване на нова начална стойност или функция на преход, трябва да изтривате динамичния масив и да започвате процеса на запазване отначало.

Помислете как трябва да се handle-не коректно копирането на обекти от вашия клас.

# Задача 3:
Дефинирайте клас ArithmeticProgression, описващ аритметична прогресия. Реализирайте:

* Конструктор по подразбиране, инициализиращ прогресията като съвпадаща с множеството на естествените числа.
* Конструктор, който приема първи член и разлика
* Оператор за събиране на прогресии. Под сума на прогресии разбираме прогресия, представляваща тяхната поелементна сума. Да се реализира и съответния оператор +=.
* Оператор за изваждане на прогресии. Под разлика на прогресии разбираме прогресия, представляваща тяхната поелементна разлика. Да се реализира и съответния оператор -=.
* Оператор за добавяне на цяло число без знак към прогресия, който създава прогресия, получена от началната с прескачане на дадения брой елементи от началото (т.е. да се измества началото).
* Оператор [], който връща на n-тия член
* Оператор (), който връща сумата на първите n члена в редицата

# Задача 4:
Дефинирайте клас Матрица с произволни размери. Реализирайте:

* конструктор с параметри - 2 числа, които да определят размера на матрицата
* конструктор по подразбиране (по default размерите са 2х2)

Оператори:

* оператор+= - за събиране на матрици
* оператор+
* оператор-= - за изваждане на матрици
* оператор-
* оператор*= - за умножаване на матрици (стига да е възможно)
* оператор*
* оператор*= - за умножаване на матрица с число
* оператор*
* оператор== - 2 матрици са равни, ако всичките им елементи са равни
* оператор!=
* оператор[] - връща реда от матрицата на съответния индекс (за константен и неконстантен достъп)
* operator bool - връща false, ако матрицата е нулевата. В противен случай връща true. Помислете за оптимизация на този оператор. Hint: mutable

# Задача 5:
Да се дефинира клас Webpage, който има следните член-данни:

* адрес (пример: "https://github.com/KristianIvanov24")
* IP адрес (пример: 52.43.12.8) Да се дефинират следните оператори:
* оператор<< и оператор >>

Да се дефинира клас Browser, който съдържа

* отворени уеб страници (не повече от 30)
* брой отворени страници

Да се дефинират следните методи:

* методи за добавяне и премахване на страница
* оператор+= за отваряне на страница
* оператор-= за затваряне на страница (по индекс)
* принтиране на отворените страници

Да се напише главна програма, която реализира следните тестове:

* Създава три страници – две от тях са въведени от потребителя от клавиатурата, а трета, е дефинира в кода, като принтира информацията за всяка от тях.
* Добавя трите страници към Browser обект.
* Прави копие на този Browser обект и след това премахва втората страница.

# Задача 6:
Напишете клас Vector, който моделира математически n-мерен вектор с целочислени координати. За класа реализирайте:

* Конструктор по подразбиране, който създава тримерен нулев вектор
* Конструктор, който приема размер и масив от цели стойности
* Функции за четене и записване в двоичен файл
* Оператор <<, който приема поток за за изход и извежда вектора във вида (a1, a2, …, an)

Да бъдат предефинирани оператори за:

* Събиране на вектори
* Изваждане на вектори.
* Умножение на вектор със скалар
* Индексация
* Проверка дали векторът е нулев
* Дължина на вектор
* Вход и изход от потоци

# Задача 7:
Напишете клас GradeReport, който съдържа следните полета:

* масив от оценки (точки в интервала от 0 до 100) с произволна дължина
* дължина на масива
* име на репорта - низ с произволна дължина
* Класът трябва съдържа следните методи:

* връща брой оценки в репорта
* връща името на репорта
