# Задача 1: 
Контейнери
Да се дефинира абстрактен клас Container, дефиниращ интерфейс на контейнер, съдържащ числа с плаваща запетая (double). Класът да дефинира следните методи:

* bool member (double x), проверяващ дали дадено число е елемент на структурата
* double operator [] (size_t i), намиращ i-тия елемент на структурата. Номерацията на елементите зависи от специфичната структура
* int count (), връща броя на елементите в структурата
* void write (), извеждащ на конзолата елементите на структурата.

Да се дефинира наследник Vector на клас Container, реализиращ вектор от числа с плаваща запетая. Размерът и елементите на вектора се задават при конструиране на обекта. Номерацията на елементите е естествена. Печатането на елементите е последователно на едни ред, разделени със запетая и оградени със скоби (например: (1,2,3))

Да се дефинира наследник Matrix на клас Container, реализиращ квадратна матрица от числа с плаваща запетая. Размерът и елементите на матрицата се задават при конструиране на обекта. Номерацията на елементите на матрицата е следната: Ако големината на матрицата е N, то елементът (aij), 0<=i<N, 0<=j<N има пореден номер i*N+j.

Да се реализира функция bool intersection (const Container** arr, size_t n, double x), която по масив от указатели към n контейнера проверява дали има такова число x, което да се съдържа във всяка една от структурите.

# Задача 2: 
Windows Forms
Windows Forms е UI framework за лесно създаване на приложения за Windows OS. Той представя лесен начин за създаване на приложения графично и се поддържа от езикци като C#. Приложенията представляват множество от форми (Forms), в които има контроли (Controls). Да се създаде клас, който представя Форма. Формата има размер (широчина и дължина) и име. Всяка форма поддържа колекция от контроли.

Всеки контрол има размер и локация във формата. Също така, всеки контрол има функция setDataDialog();, която позволява на потребителя да промени контрола по подходящ начин. Всеки контрол може да променя размерите си. Имаме следните контроли:

TextBox - Контрол, в който се подава текст. setDataDialog() променя текста му. check

CheckBox - Контрол, който има текст и състояние (включен или изключен). setDataDialog() променя дали е включен или изключен по подразбиране. За промяна на текста може да добавите допълнителна функция. radio

RadioButton - Контрол, който има няколко опции, но само една е избрана. setDataDialog() променя избраната опция. Може да добавите допълнителна логика за промяната на опциите. Броят им, веднъж зададен, не се променя. radio

Реализирайте хетерогенен контейнер, който съдържа различните контроли, които вашата форма притежава. Трябва да имате следните методи:

* метод за добавяне на контрола към контейнера
* метод за променяне на размера на формата, както и на всеки от контролите (може да достъпвате контролите по индекс)
* функция за промяна на локацията на контролите, като те не трябва да излизат извън формата
* метод change(size_t index); който променя контрола на подадения индекс. Промяната става чрез извикване на setDataDialog функцията на съответния контрол.

# Задача 3: 
Smart Home System
Трябва да разработите програма за управление на различни типове устройства в система за "умни домове". Системата поддържа устройства като Smart Light, Smart Thermostat и Smart Speaker. Всеки тип устройство има специфични атрибути и поведение.

Изисквания: Абстрактен базов клас Device със следните pure virtual функции:

* turnOn()
* turnOff()
* printDetails()

Освен тях, базовият клас има име и производител (MyString) и цена (реална стойност).

Класът Device има следните 3 наследници:

* SmartLight : има атрибут brightnessLevel, отговарящ за светимостта.
* SmartThermostat: има атрибути за настояща температура и желана температура.
* SmartSpeaker: има допълнително поле за сила на звука.
Презапишете функциите turnOn, turnOff и printDetails за всеки от класовете, така че да изписват на конзолата конкретно съобщение за вида смарт устройство.

Създайте и клас SmartHome, който да представлява хетерогенен контейнер от смарт устройтва. Класът да поддържа и следните функционалности:

* Добавяне на смарт устройство
* Премахване на смарт устройство
* Принтиране на всички налични устройства
* Включване/изключване на устройство на подаден индекс
* Намиране на средна цена на устройства от даден производител

# Задача 4:
Хетерогенен контейнер
Реализирайте абстрактен клас "SubjectInFMI", който притежава следните атрибути:

* име на предмета
* име на лектор
* списък от имената на асистентите
* точки за преминаване (int)
Следните член-функции трябва да се имплементират от наследниците:

* gradeToPass()
  * Ако предметът е ДИС - 70% oт точките са нужни за преминаване
  * Ако предметът е ООП - 80% oт точките са нужни за преминаване
  * Ако предметът е ДСТР2 - 60% oт точките са нужни за преминаване
  * Ако предметът е УП - 50% от точките са нужни за преминаване
  * Ако предметът е ГЕОМЕТРИЯ - 75% oт точките са нужни за преминаване
  * getSubjectName() - отпечатва името на предмета

Предментите във ФМИ са:

Диференциално и интегрално смятане (DIS/Calculus):
* OOП - има допълнителен атрибут - бонус точки, които се включват към финалната оценка
* ДСТР2
* УП
* ГЕОМЕТРИЯ
Реализирайте подходящ клас, който менажира контейнер от предметите във фми. Той трябва да има:

член-функция връщаща размера
предмета, който се среща най-много пъти в контейнера

# Задача 5: 
Да се реализира абстрактен базов клас Item, който описва елемент на екрана на мобилно устройство. Всеки такъв елемент има заглавие - символен низ. Това заглавие трябва да може да се извлича от обект, който е Item. Също така, всеки елемент трябва да отговаря на запитване canMove, което отговаря дали елементът може да бъде местен по екрана.

В програмата трябва да се поддържат следните типове елементи:

* App - описва икона на мобилно приложение с дадено име. Елементите от този тип могат да се местят. Името се задава в конструктора, но може да се променя в по-късен етап.

* Widget - описва системен елемент. Системните елементи не могат да се местят и всички имат едно и също име по подразбиране “System Widget". Позволете това име да може да се променя за всички елементи (например при промяна на езика на системата).

* Folder, който описва папка съдържаща елементи от вид Item. Папката може да бъде местена по екрана. Името на папката представлява списък от имената на всички елементи в нея, разделени със запетая. Трябва да можете да добавяте и премахвате елементите в папката. Не се позволяват два елемента с едно и също име. Трябва да можете да индексирате елементите по името им чрез подходящи предефинирани оператори.

# Задача 6: 
Computer Components Configuration
Един компютър се състои от един или повече компоненти. Всички компоненти са immutable обекти. След като веднъж бъдат създадени, свойствата им не могат да се променят. Всеки компонент да има:

Етикет, който е символен низ с произволна дължина
Функция double price() const, която връща цената на компонента. Тя ще се имплементира от всеки конкретен компонент и ще пресмята цената по някакво правило.
Фунцкия void output(std::ostream) const, която ще принтира данните за компонента. Тя ще се имплементира от всеки конкретен компонент.
Програмата ви трябва да поддържа два конкретни компонента – процесор (CPU) и памет (Memory).

Процесорът има брой ядра (cores) и честота в MHz (clock speed). И двете са числа от тип unsigned short. Броят на ядрата може да е между 1 и 8. Цената на процесора се смята като броя на ядрата, умножен по 29.99 лева. Паметта има капацитет (capacity) в гигабайти (GBs) (unsigned short). Трябва да е число между 1 и 10000 Цената на паметта е 89.99 лева на гигабайт.

Ако се опита да се създаде компонент с некоректно подадени параметри, да се хвърли изключение.

Реализирайте подходяща йерархия, за да представите горе-описаната ситуация. Проектирайте йерархията по всички добри практики, така че да позволява лесно добавяне и на други видове компоненти в бъдеще. Например помислете какъв трябва да е деструкторът, кои операции да са pure virtual и кои да изнесете в базовия клас и т.н.

Напишете клас Configuration, представящ конфигурация. Класът трябва да може да съхранява в себе си различни видове компоненти. Класът да има следните член-функции:

* void insert(Component* component), която добавя нов компонент към конфигурацията. Функцията директно да съхранява указателя, без да прави копие на подадения компонент.
* double price() const – връща цената на конфигурацията. Пресмята се като сума от цените на всички компоненти.
* size_t size() const – връща броя на компонентите в конфигурацията.
За класа предефинирайте следните оператори:

* operator [] - позволява константен достъп до обект в конфигурацията
* operator <<, който извежда информация за конфигурацията в std::ostream. При извеждането най-напред да се изведат един по един всички компоненти, използвайки техните функции output. Накрая, да се изведе и още един ред с общата цена на конфигурацията.
Напишете factory функция Component* Create_Component(). Тя трябва да попита потребителя какъв тип компонент иска да създаде – процесор или памет. След това тя въвежда съответните му характеристики, създава динамично обект от съответния тип и го връща. Ако потребителят въведе невалиден тип или създаването на обект е неуспешно, да се върне nullptr.

# Задача 7: 
Реализирайте клас Човек, който се характеризира с три имена (символни низове с дължина не по-голяма от 30 символа всеки) и ЕГН. Не позволявайте наличие на човек без поне две имена и ЕГН. Второто име може да е празно. След създаване на обекта ЕГН-то не трябва да може да се променя. В тази задача не се очаква да реализирате валидация на ЕГН, освен коректна дължина (точно 10 цифри). Дефинирайте подходящи методи за достъп до членовете на класа. Дефинирайте оператори == и != за сравняване на два обекта от класа за равенство (изберете подходящ критерий).

Реализирайте клас Група, който представлява множество от обекти Човек, което може да съдържа произволен брой обекти. Не трябва да има повтарящи се обекти (съгласно дефиницията на оператора ==).

За този клас реализирайте възможност за достъп до броя на обектите в него. Реализирайте следните оператори:

* оператори + и += с десен аргумент Човек, които добавят човека към текущата група;
* оператори - и -= с десен аргумент Човек, които премахват човека от текущата група;
* оператор за индексиране, който приема аргумент ЕГН (според избрания от вас тип за класа Човек) и връща псевдоним към човека с това ЕГН или хвърля подходящо изключение, ако няма такъв човек.
* оператор () без аргументи, който връща броя на хората в групата.
* оператор() с един аргумент от тип Човеек, който връща булева стойност и проверява дали човекът е в групата, или не.

Реализирайте клас Екип, който представлява група хора, между някои от които има йерархични взаимоотношения - ръководител-подчинен. Изберете подходящ начин за представяне на тези взаимоотношения, като имате предвид, че всеки човек може да има само един ръководител. Възможно е един ръководител да има много подчинени, както и той самият да бъде в роля подчинен спрямо друг ръководител.

* Реализирайте оператор () с два аргумента от тип Човек, който задава първия си аргумент като ръководител на втория, в случай че и двамата са членове на екипа. Връща булев резултат - дали операцията е успешна. Ако вторият служител вече има зададен ръководител, той се променя.
Реализирайте оператори за наредба на два екипа, като по-голям е този екип, в който има повече ръководители (хора с поне един подчинен).
