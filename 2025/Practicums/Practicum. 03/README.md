# Задача 1. 
Да се напише програма, която чете матрица от текстов файл от вида : 3,3,3|1,1,3|3,3,1, чете друга матрица в същия формат от втория файл и записва произведението им в нов файл (броят на колоните винаги е 3).

# Задача 2.  
Да се напише структура, която съхранява информация за доставка на пица. Да се създаде масив от доставки - списък с поръчки. Една поръчка съдържа име на клиента (до 50 символа), телефонен номер (до 20 символа), адрес на потребителя(до 100 символа), общата стойност на доставката и броят пици. Структурата на пицата трябва да съдъжа типа на пицата { Маргарита, калцоне, бурата и каквато още пожелаете}, размер на пицата {S,M,L}, цена на пицата. Да се имплементират функции, които позволяват съхраняването и изчитането на информацията за поръчките от двоичен файл. Да се сортират поръчките в масива по адрес на доставка и да се запише в нов двоичен файл.

# Задача 3. 
Да се създаде структура Jedi със следните характеристики:

* Име (максимална дължина 50 символа)
* Възраст
* Сила
* LightSaber
Всеки лазер да се опише със следните полета:

* Цвят - RED, YELLOW, GREEN, BLUE, PURPLE
* Тип - SINGLEBLADED, DOUBLE_BLADED, CROSSGUARD

Да се напише структура JediCollection, която да може да пази в себе си най-много 100 джедая и техния брой. Да се реализира следния набор от функции:

* Jedi createJedi(const char* name, unsigned age, unsigned power, const LightSaber& saber) – създава нов джедай с подадените параметри. Да се реализира overload, приемащ създаден цвят и тип на лазер
* void addJedi(JediCollection& collection, const Jedi& jedi) – добавя джедай в подадената колекция
* void removeJedi(JediCollection& collection, const char* name) – премахва джедая с подаденото име от колекцията
* void printJediCollection(const JediCollection& collection) – принтира подадената колекция
* void saveCollectionToBinary(const char* fileName, const JediCollection& collection) – запазва колекцията в подадения двоичен файл
* JediCollection readCollectionFromBinary(const char* fileName) – прочита и създава колекция, записана в двоичен файл
* void saveCollectionToTxt(const char* fileName, const JediCollection& collection) – запазва колекцията в подадения текстов файл
* JediCollection readCollectionFromTxt(const char* fileName) – прочита и създава колекция, записана в текстов файл
* void sortByAge(JediCollection& collection) – сортира колекция във възходящ ред по възраст
* void sortByPower(JediCollection& collection) – сортира колекция във възходящ ред по сила
* Color mostPopularSaberColor(const JediCollection& collection) – връща най-използвания цвят на лазер от джедаите в колекцията
* Type mostPopularSaberType(const JediCollection& collection) – връща най-използвания тип на лазер от джедаите в колекцията

# Задача 4. 
Да се напише структура Car, която да съдържа, марка (enum class, създайте няколко енумератора по избор) име на собственик (символен низ с максимална дължина 24 символа), средна скорост (реална стойност), стойности на наложени глоби (реални стойности, най-много 20) и техния брой

* Да се напише функция, която пресмята сумата от всички глоби на дадена кола.
* Да се напише функция, която добавя глоба към дадена кола. Функцията да не прави нищо, ако максималният брой глоби е достигнат.
* Да се нашише функция, която извежда на стандартния изход информацията за дадена кола.
* Да се напишат функции за четене и записване на студент в подаден двоичен файл.
* Бонус: Да се напише функция, която чете масив от коли с произволна дължина от двоичен файл. Функцията сортира колите по средна скорост във възходящ ред и ги записва обратно в двоичния файл.

# Задача 5. 
Да се направи функция, която "разшифрова" скрито съобщение. Съобщението представлява двоичен файл с неизвестна дължина. Това, което съхранява е поредица от цели неотрицателни числа.

"Ключът" за съобщението се съхранява в друг двоичен файл и представлява число в интервала [0, 255]. Преценете как е най-подходящо да прочетете и съхраните ключа. Шифърът за получаване на правилното съобщение е към всяко число от прочетения файл, съдържащ съобщението да се добави стойността на прочетения ключ

Пояснение: Aко файлът със скритото съобщение след прочитане изглежда така: 23 48 3 12 4006, файлът, съдържащ ключа има стойност 2, то разшифрованото съобщение трябва да е: 25 50 5 14 4008. Изведете разшифрованото съобщение на конзолата.

# Задача 6.
Имате файл, съдържащ записи, които са организирани в свързан списък. Някои от записите във файла вече не се използват (били са премахнати от списъка и вече не са част от него). За съжаление, по GDPR вие нямате право да пазите дълго време потребителски данни, които не се използват – затова трябва да напишете програма, която цензурира неизползваните записи.

Програмата се извиква с един аргумент (име на файл): maintasks.db

Файлът се състои от последователни 512-байтови записи, всеки от които описва възел и има следния вид:

* next: 8 байта, представящи 64-битово число без знак – индекс на следващия възел (в брой записи спрямо началото на файла), или 0 , ако след този възел няма следващ
* user_data: 504 байта потребителски данни
Първият възел от списъка е винаги първи запис във файла (с индекс 0). Всеки следващ възел може да е на произволно място във файла.

Забележки:

* Забележете, че последният възел от списъка (този, който има next == 0) най-вероятно няма да е последният запис във файла
* Може да приемете, че възлите, които са в списъка, няма да образуват цикъл
